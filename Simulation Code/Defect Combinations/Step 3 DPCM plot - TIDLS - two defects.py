import matplotlib.pyplot as plt
import numpy as np
import matplotlib.cm as cm
from numpy import *
from pylab import *
from progressbar import ProgressBar
pbar = ProgressBar()
import matplotlib.ticker as mtick
import csv
import os
import os.path

params = {'text.usetex': False, 'mathtext.fontset': 'stixsans'}
plt.rcParams.update(params)

#Defect Parameter Contour Mapping:
#A procedure to unravel the identity of defects limiting lifetime in c-Si from temperature- and injection-dependent lifetime spectroscopy (TIDLS) data
#Written by Tine Uberg Naerland 2016

#Ranges and resolution:
Et = np.linspace(0.0, 1.125, num=150)
k = np.logspace(-3, 3, num=150)
tau_p0 = np.logspace(-13, -3, num=700)

#Simulated raw data, basis for the fit, generated by sister script
Temperatures = [298, 328, 358, 388, 418, 448, 478]
Injections = np.logspace(13, 16, num=6)

#Function that calculates tau_eff with input from the loop below
def calculate_tau_effective(Et, k, tau_p0, delta_n, T):
    # Specific for this case

    p0 = 2e15  # cm-3
    #ni = 1.2e10 #cm-3


    # Firm constants:
    Ev = 0.0  # eV
    Ec = 1.120000  # eV
    k_b = 1.38e-23  # m2Ks-2K-1
    q = 1.602e-19  # C

    #Temperature dependence
    Nc = 2.86e19 * (T/300.0)**1.58 #cm-3 #Green 1990
    Nv = 3.1e19 * (T/300.0)**1.85 #cm-3 #Green 1990
    Eg = 1.1752165 - ((0.000473*T**2)/(T+636.0)) #eV Altermatt 2011
    ni = 2.9738e19 * ((T/300.0)**1.5)*exp((-q*Eg)/(2*k_b*T)) #cm-3 Mackel 2012
    n0 = ni**2/p0
    n = n0 + delta_n
    p = p0 + delta_n

    #Auger parameters: Richters model for intrinsic recombination (Auger + radiative)
    b_max = 1.0
    b_2 = 0.54
    b_4 = 1.25
    r_max = 0.2
    r_min = 0.0
    r_1 = 320.0
    r_2 = 2.50
    s_max = 1.5e18
    s_min = 1.0e7
    s_1 = 550.0
    s_2 = 3.0
    w_max = 4.0e18
    w_min = 1.0e9
    w_1 = 365.0
    w_2 = 3.54

    b_min = r_max+((r_min-r_max)/(1+(T/r_1)**r_2))
    b_1 = s_max+((s_min-s_max)/(1+(T/s_1)**s_2))
    b_3 = w_max+((w_min-w_max)/(1+(T/w_1)**w_2))

    B_rel = b_min + ((b_max-b_min)/(1+((n+p)/(2*b_1))**b_2+((n+p)/(2*b_3))**b_4))

    if T > 1 and T <= 120:
        B_low = 3.4714e-7 * T**-3.5191
    if T > 120 and T < 600:
        B_low = 2.6009e-12 * T**-1.1107

    N0_eeh = 3.3E+17
    N0_ehh = 7.0E+17


    geeh = 1 + 13.0 * (1.0 - tanh((n0 / N0_eeh)**0.66))
    gehh = 1 + 7.5 * (1.0 - tanh((p0 / N0_ehh)**0.63))
    tau_intr = 1.0e6 * delta_n/((((n0 + delta_n)*(p0 + delta_n))-ni**2) * (2.5e-31 * geeh * n0 + 8.5e-32 * gehh * p0+3e-29* delta_n**0.92 + B_rel * B_low))

    # SRH Equations:
    n1 = Nc * exp((-(Ec - Et) * q) / (k_b * T))
    p1 = Nv * exp((-(Et - Ev) * q / (k_b * T)))
    tau_SRH = 1e6*((tau_p0/k)*(p0 + p1 + delta_n)+tau_p0*(n1+delta_n))/(p0+n0+delta_n) #p-type
    #tau_SRH = 1e6*(tau_p0*(n0 + n1 + delta_n)+((tau_p0/k)*(p1+delta_n)))/(n0+p0+delta_n)  # n-type
    #tau_eff = 1/((1/tau_SRH)+(1/tau_intr))
    tau_eff = 1/((1/tau_SRH))
    return tau_eff


def populate_min_matrix(Simulated_TIDLS_curves):
    # Populate a matrix of minimum tau_p0 values for later use
    tau_p0_list = []
    for Et_value in Et:
        minvalues = []
        for k_value in k:
            tau_p0_local = find_tau_p0_giving_min_residualvalue_for_first_T_curve(Et_value, k_value, Simulated_TIDLS_curves)
            minvalues.append(tau_p0_local)
        tau_p0_list.append(minvalues)
    return tau_p0_list

#calculate tau_p0 giving min_residualvalue for first T curve
def find_tau_p0_giving_min_residualvalue_for_first_T_curve(Et_value, k_value, Simulated_TIDLS_curves):
    list_of_residualvalue_for_all_tau_p0 = []
    for tau_p0_value in tau_p0:
        list_of_residualvalue_for_full_delta_n_range = []
        Simulated_TIDLS_series = Simulated_TIDLS_curves[0]
        for delta_n in range(0, len(Injections)): #Calculate the smallest deviation for the Et-k combination for the lowest T
            delta_n_value = Injections[delta_n]
            tau_measured = Simulated_TIDLS_series[delta_n]
            tau_eff = calculate_tau_effective(Et_value, k_value, tau_p0_value, delta_n_value, Temperatures[0])
            residualvalue_delta_n=100*(np.absolute(tau_eff-tau_measured))/(tau_measured)
            list_of_residualvalue_for_full_delta_n_range.append(residualvalue_delta_n)
        residualvalue_average1=np.average(list_of_residualvalue_for_full_delta_n_range)
        residualvalue_average=np.absolute(residualvalue_average1)
        list_of_residualvalue_for_all_tau_p0.append(residualvalue_average)
    min_residualvalue_value = np.amin(list_of_residualvalue_for_all_tau_p0)

    for i in range(0,len(list_of_residualvalue_for_all_tau_p0),1):
        if list_of_residualvalue_for_all_tau_p0[i] == min_residualvalue_value:
            #print "Returning value for initial (j=0) tau_p0_value: " + tau_p0[i]
            return tau_p0[i]

def read_csv_file(lifetime_file):
    f = open(lifetime_file)
    csv_f = csv.reader(f)

    result = []
    for row in csv_f:
        values = []
        for value in row:
            values.append(value)
            #print value
        result.append(values)

    first_T = result[0]
    first_T=np.array(first_T, dtype=float)
    second_T = result[1]
    second_T=np.array(second_T, dtype=float)
    third_T = result[2]
    third_T=np.array(third_T, dtype=float)
    forth_T = result[3]
    forth_T=np.array(forth_T, dtype=float)
    fift_T = result[4]
    fift_T=np.array(fift_T, dtype=float)
    sixt_T = result[5]
    sixt_T=np.array(sixt_T, dtype=float)
    seventh_T = result[6]
    seventh_T=np.array(seventh_T, dtype=float)

    return [first_T, second_T, third_T, forth_T, fift_T, sixt_T, seventh_T]

def write_to_file(metrics, path):
    f = open(path[:-4] + '_metrics.txt', 'w')
    for key, value in metrics.iteritems():
        f.write('%s\t%s\n' % (key, value))
    f.close()


"""
#Logging what tau_p0 values are used as best fit:
list_of_tau_p0_min_ResidualValue_first_j=[]
for Et_value in Et:
    for k_value in k:
        tau_p0_min_ResidualValue_first_j = find_tau_p0_giving_min_residualvalue_for_first_T_curve(Et_value, k_value)
        #print tau_p0_min_ResidualValue_first_j
        list_of_tau_p0_min_ResidualValue_first_j.append(tau_p0_min_ResidualValue_first_j)
min_tau_p0_value_used_in_plot=np.amin(list_of_tau_p0_min_ResidualValue_first_j)
print "-"
print "minimum tau_p0 value used in the DCPM plot:"
print min_tau_p0_value_used_in_plot
max_tau_p0_value_used_in_plot=np.amax(list_of_tau_p0_min_ResidualValue_first_j)
print "maximum tau_p0 value used in the DCPM plot:"
print max_tau_p0_value_used_in_plot
"""

def calculate_residualvalues_for_plot(Simulated_TIDLS_curves, Et, k, tau_p0_list):
    #Calculate Et-k min_residualvalue values for the number of Simulated_TIDLS_curves(j) using the tau_p_0 returned above
    residualvalue_all=[]
    metrics = {}
    for j in range(0, len(Simulated_TIDLS_curves)):
        residualvalue = [] #Have to make this one separate between the lists of residualvalue for the different j's
        for y in range(0, len(Et)):
            for z in range(0, len(k)):
                Et_value = Et[y]
                k_value = k[z]
                tau_p0_min_residualvalue_first_j = tau_p0_list[y][z]

                list_of_residualvalue_for_full_delta_n_range=[]
                for delta_n in range(0, len(Injections)):
                    delta_n_value = Injections[delta_n]
                    tau_measured = Simulated_TIDLS_curves[j][delta_n]
                    tau_eff = calculate_tau_effective(Et_value, k_value, tau_p0_min_residualvalue_first_j, delta_n_value, Temperatures[j])
                    residualvalue_delta_n=100*(np.absolute(tau_eff-tau_measured))/(tau_measured)

                    list_of_residualvalue_for_full_delta_n_range.append(residualvalue_delta_n)
                residualvalue_average1=np.average(list_of_residualvalue_for_full_delta_n_range)
                residualvalue_average=np.absolute(residualvalue_average1)
                residualvalue.append((Et_value, k_value, residualvalue_average))
        residualvalue_all.append(residualvalue)

    list_of_average_residualvalue = []
    metadata = []
    for index in range(0, len(residualvalue_all[0])):
        values = []
        temp_E = None
        temp_k = None
        for j in range(0, len(Simulated_TIDLS_curves)):
            values.append(residualvalue_all[j][index][2])
            temp_E = residualvalue_all[j][index][0]
            temp_k = residualvalue_all[j][index][1]
        average = np.average(values)
        list_of_average_residualvalue.append(average)
        metadata.append((temp_E, temp_k, average))

    #Finding the Et-k  combination giving the smallest residual value

    min_residual_value_used_in_plot=np.amin(list_of_average_residualvalue)
    metrics['min_residual_value_used_in_plot'] = min_residual_value_used_in_plot

    for residual_value in metadata:
        if residual_value[2] == min_residual_value_used_in_plot:
            metrics['min_residual_value_used_in_plot'] = min_residual_value_used_in_plot
            metrics['min_residual_value_used_in_plot_Et'] = residual_value[0]
            metrics['min_residual_value_used_in_plot_k'] = residual_value[1]

    #Finding error on residual_value:
    Error_percentage = 2.5 + min_residual_value_used_in_plot
    #Area to look for error
    smallest_Et = 0.0
    largest_Et = 1.2
    smallest_k = 0.0001
    largest_k = 1000

    #Dont touch these:
    min_Et = max(Et)
    max_Et = 0
    min_k = max(k)
    max_k = 0

    for residual_value in metadata:
        if residual_value[2] < Error_percentage and smallest_Et < residual_value[0] < largest_Et and smallest_k < residual_value[1] < largest_k:
            #print "I found error limit " +str(residual_value[2])
            if residual_value[0] < min_Et:
                min_Et = residual_value[0]
            if residual_value[0] > max_Et:
                max_Et = residual_value[0]

            if residual_value[1] < min_k:
                min_k = residual_value[1]
            if residual_value[1] > max_k:
                max_k = residual_value[1]

    metrics['min_Et'] = str(min_Et)
    metrics['max_Et'] = str(max_Et)
    metrics['min_k'] = str(min_k)
    metrics['max_k'] = str(max_k)

    return list_of_average_residualvalue, metrics


def make_contour_plot(Et, k, list_of_average_residualvalue, filepath, filename):

    x = np.array(k)
    y = np.array(Et)

    z = np.array(np.absolute(list_of_average_residualvalue))
    z.shape = (len(Et), len(k))

    map_size = [8.5,5]
    #fig, ax = plt.subplots(1,1,figsize=map_size)
    ax = subplot(111)
    cmap = cm.get_cmap('PuBu')
    vmin=0 #np.amin(min_R2_tau_p0_values)
    vmax=30
    cs = plt.pcolor(x, y, z, cmap=cmap, vmin=vmin, vmax=vmax)
    cb = plt.colorbar(cs, orientation = 'vertical', ticks=[linspace(0,vmax,num=11)],  format='%0.1f')
    #levels = [11] #np.arange(20,25,5)

    fontsize_numbers=16
    fontsize_labels=20
    cb.ax.tick_params(labelsize=fontsize_numbers)
    cb.set_label('Average Residual Value (%)', fontsize=20) #), rotation=0)
    ax.set_xscale("log")
    ax.set_xlim(min(k),max(k))
    ax.set_ylim(min(Et),max(Et))
    ax.set_yticks(linspace(min(Et),max(Et),num=12))
    ax.yaxis.set_major_formatter(mtick.FormatStrFormatter('%.1f'))
    ax.tick_params(which = 'both', direction = 'out')
    plt.tick_params(labelsize=fontsize_numbers)
    plt.xlabel('Capture Cross Section Ratio',fontsize=fontsize_labels)
    plt.ylabel(('Defect Energy Level ($eV$)'),fontsize=fontsize_labels)
    plt.tight_layout()

    #Defect annotation

    Element = ['name', Et, k]
    Au_a=[r'$\rm{Au_s(a)}$', 0.574, 0.02]
    Au_d=[r'$\rm{Au_s(d)}$', 0.35, 1.1]
    Cr_d=[r'$\rm{Cr_i(d)}$', 0.884, 5] #Schmidt, JAP, 2007
    Co_a=[r'$\rm{Co_s(a)}$', 0.74, 0.15]
    Co_d=[r'$\rm{Co_s(d)}$', 0.41, 16]
    Cu_a=[r'$\rm{Cu_s(I)^*}$', 0.92, 0.05] #D. Macdonald,2002.
    Cu_d=[r'$\rm{Cu_s(II)}$', 0.62, 16] #D. Macdonald, 2002
    Fe_i_d=[r'$\rm{Fe_i(d)^*}$', 0.38, 186] #Macdonald 2008
    FeB=[r'$\rm{FeB(a)^*}$', 0.86, 13] #Scmidt 2005
    Mn_d=[r'$\rm{Mn_i(d)}$', 0.64, 9.4]
    #Mn_dd=[r'$\rm{Mn_i(dd)^*}$', 0.35, 26]
    Mo_d=[r'$\rm{Mo_i(d)}$', 0.28, 30] #Macdonald, APL, 85, 4061, 2004
    Ni_a=[r'$\rm{Ni_s(a)}$', 0.72, 0.7]
    Ni_d=[r'$\rm{Ni_s(d)}$', 0.19, 4000]
    Pt_s=[r'$\rm{Pt_s(II)^*}$', 0.89, 1.12] #Graff
    Pt_sd=[r'$\rm{Pt_s(I)^*}$', 0.32, 0.01] #Graff
    Ti_d=[r'$\rm{Ti_i(d)}$', 0.854, 22] # Macdonald, APL, 85, 4061, 2004
    Ti_dd=[r'$\rm{Ti_i(dd)^*}$', 0.26, 460] #Macdonald, APL, 85, 4061, 2004
    Tine=[r'$\rm{Defect X}$', 0.56, 1]
    W_s=[r'$\rm{W_s(d)}$', 0.31, 7.5]
    Zn_a=[r'$\rm{Zn_s(a)}$', 0.33, 0.34]
    Zn_aa=[r'$\rm{Zn_s(aa)}$', 0.654, 0.00002]

    color = 'w'
    horizontalalignment = 'center'
    verticalalignment = 'bottom'
    fontsize = 13
    markersize = 4
    offset = 0.005

    # plotting the defects
    plt.plot(Au_a[2], Au_a[1],'o', color=color, markersize=markersize)
    ax.annotate(Au_a[0], xy=(Au_a[2], Au_a[1]+offset), ha = horizontalalignment, va = verticalalignment, color=color, fontsize=fontsize)

    plt.plot(Cu_a[2], Cu_a[1],'o', color=color, markersize=markersize)
    ax.annotate(Cu_a[0], xy=(Cu_a[2], Cu_a[1]+offset), ha = horizontalalignment, va = verticalalignment, color=color, fontsize=fontsize)

    plt.plot(Cu_d[2], Cu_d[1],'o', color=color, markersize=markersize)
    ax.annotate(Cu_d[0], xy=(Cu_d[2]-0.02, Cu_d[1]), ha = 'left', va = 'top', color=color, fontsize=fontsize)

    plt.plot(Mo_d[2], Mo_d[1],'o', color=color, markersize=markersize)
    ax.annotate(Mo_d[0], xy=(Mo_d[2], Mo_d[1]), ha = horizontalalignment, va = 'top', color=color, fontsize=fontsize)

    plt.plot(Pt_s[2], Pt_s[1],'o', color=color, markersize=markersize)
    ax.annotate(Pt_s[0], xy=(Pt_s[2], Pt_s[1]+offset), ha = horizontalalignment, va = verticalalignment, color=color, fontsize=fontsize)

    plt.plot(Pt_sd[2], Pt_sd[1],'o', color=color, markersize=markersize)
    ax.annotate(Pt_sd[0], xy=(Pt_sd[2], Pt_sd[1]+offset), ha = horizontalalignment, va = verticalalignment, color=color, fontsize=fontsize)

    plt.plot(Ti_d[2], Ti_d[1],'o', color=color, markersize=markersize)
    ax.annotate(Ti_d[0], xy=(Ti_d[2], Ti_d[1]+offset), ha = 'left', va = 'center', color=color, fontsize=fontsize)

    plt.plot(Tine[2], Tine[1],'o', color=color, markersize=markersize)
    ax.annotate(Tine[0], xy=(Tine[2], Tine[1]+offset), ha = horizontalalignment, va = verticalalignment, color=color, fontsize=fontsize)

    plt.plot(Zn_a[2], Zn_a[1],'o', color=color, markersize=markersize)
    ax.annotate(Zn_a[0], xy=(Zn_a[2], Zn_a[1]), ha = 'right', va = 'top', color=color, fontsize=fontsize)

    trans = ax.get_xaxis_transform() # x in data untis, y in axes fraction
    plot_filename = filepath + '/' + filename[:-4] + '.png'
    plt.savefig(plot_filename)
    plt.close()
    print "Plot completed and saved to file " + plot_filename

##########################################
# Execute

# Read directory structure to find csv files for combination of defects for fractions a-e.
root_path = './tau_p0_data/'
lifetime_files = []
for root, dirs, files in os.walk(root_path):
    print "ROOT: " + root
    print "DIRS: " + str(dirs)
    print "FILES: " + str(files)

    for file in files:
        print "FILE: " + file
        full_path = os.path.join(root, file)
        print "FULL PATH: " + full_path
        ext = os.path.splitext(file)[1]
        filename = os.path.splitext(file)[0]
        if ext == '.txt' and filename.endswith('curves'):
            lifetime_files.append({'full_path': full_path, 'directory': root, 'filename': file})
            print "Found someting"

for lifetime_file in lifetime_files:
    Simulated_TIDLS_curves = read_csv_file(lifetime_file['full_path'])
    tau_p0_list = populate_min_matrix(Simulated_TIDLS_curves)
    list_of_average_residualvalue, metrics = calculate_residualvalues_for_plot(Simulated_TIDLS_curves, Et, k, tau_p0_list)
    write_to_file(metrics, lifetime_file['full_path'])
    make_contour_plot(Et, k, list_of_average_residualvalue, lifetime_file['directory'], lifetime_file['filename'])
